{"./":{"url":"./","title":"Introduction","keywords":"","body":"前端开发规范 说明 这本书是公司前端开发的规范,作为所有参与前端开发人员的指南,希望开发人员在这本书的参考下能够高效,规范,统一地编写前端代码. 内容 这本书将包含js,css,vue的规范,代码风格,注意事项,以及对开发人员的建议. 目标 希望每一个参与前端开发的人员都能严格遵守本规范. 路线图 这本书将会持续保持更新,将会包含更多,更细的内容,收集大家的反馈不断进行完善. "},"javascript开发规范.html":{"url":"javascript开发规范.html","title":"javascript开发规范","keywords":"","body":"Javascript 开发规范 不要使用没有终点的循环 ❌ for(let i = 0; i 0; i++){} ✔ for(let i = 0; i 不要在if,while,for语句的条件中出现常量表达式,不要在?:运算符的条件中出现常量表达式 ❌ if(false){} // typeof 任何值都不为false while(typeof x){} let c = 0 ? a : b ✔ if(x === false){} while(typeof x === 'undefined'){} let c = x === 0 ? a : b getter应该有返回值 ❌ let p = { get name(){} } class p { get age(){} } Object.defineProperty(p, 'name', { get: function(){} }) ✔ let p = { get name(){ return 'jack' } } class p { get age(){ return 6 } } Object.defineProperty(p, 'name', { get: function(){ return 'Tom' } }) 不要在循环体中使用await 在迭代器的每个元素上执行运算是个常见的任务。然而，每次运算都执行 await，意味着该程序并没有充分利用 async/await 并行的好处。 通常，代码应该重构为立即创建所有 promise，然后通过 Promise.all() 访问结果。否则，每个后续的操作将不会执行，直到前一个操作执行完毕。 示例 async function getAllData() { let result = [] for (let i = 0 i res.data)) } return await Promise.all(result) } async function test() { let start = Date.now() await getAllData() console.log(`在循环中使用await耗时:${Date.now() - start}ms`) start = Date.now() await getAllData2() console.log(`不在循环中使用await耗时:${Date.now() - start}ms`) } test() /* console输出: 在循环中使用await耗时:1016ms 不在循环中使用await耗时:204ms */ 禁止在对象字面量中出现重复key 如果对象字面量中出现多个属性有同样的键可能会到导致意想不到的情况出现。 ❌ let foo = { x: 1, y: 2, x: 1 } ✔ let foo = { x: 1, y: 2, z: 1 } 禁止在 switch 语句中的 case 子句中出现重复的测试表达式。 ❌ let x = 1 switch(x){ case 1: break case 2: break case 1: // 重复的case break default: break } ✔ let x = 1 switch(x){ case 1: break case 2: break case 1: // 重复的case break default: break } 在正则表达式中空字符集[]不能匹配任何字符，它们可能是打字错误。 ❌ /^abc[]/.test('abcdefg') // 结果为 false 'abcdefg'.match(/^abc[]/) // 结果为 null ✔ /^abc[a-z]/.test('abcdefg') // 结果为 true 'abcdefg'.match(/^abc[a-z]/) // 结果为 ['abcd'] 禁止不必要的布尔类型转换 在上下文中比如 if 语句的测试表达式的结果已经被强制转化成了一个布尔值，再通过双重否定（!!）或 Boolean 转化是不必要的。例如，这些 if 语句是等价的： if (!!x) { // ... } if (Boolean(x)) { // ... } if (x) { // ... } ❌ let foo = !!!bar let foo = !!bar ? baz : bat let foo = Boolean(!!bar) let foo = new Boolean(!!bar) if (!!foo) { // ... } if (Boolean(foo)) { // ... } while (!!foo) { // ... } do { // ... } while (Boolean(foo)) for ( !!foo ) { // ... } ✔ let foo = !!bar let foo = Boolean(bar) function foo() { return !!bar } let foo = bar ? !!baz : !!bat 禁止对 function 声明重新赋值 JavaScript 函数有两种形式：函数声明 function foo() { ... } 或者函数表达式 let foo = function() { ... } 。虽然 JavaScript 解释器可以容忍对函数声明进行覆盖或重新赋值，但通常这是个错误或会导致问题出现。 ❌ function foo() {} foo = bar function foo() { foo = bar } foo = bar function foo() {} ✔ let foo = function () {} foo = bar function foo(foo) { // `foo`是局部变量 foo = bar } function foo() { let foo = bar // `foo`是局部变量 } 禁止在 RegExp 构造函数中出现无效的正则表达式 在正则表达式字面量中无效的模式在代码解析时会引起 SyntaxError，但是 RegExp 的构造函数中无效的字符串只在代码执行时才会抛出 SyntaxError。 ❌ RegExp('[') RegExp('.', 'z') new RegExp('\\\\') ✔ RegExp('\\\\[') RegExp('.','g') new RegExp('\\\\\\\\') 禁止直接使用 Object.prototypes 的内置属性 ECMAScript 5.1 新增了 Object.create，可以通过它创建带有指定的 [[Prototype]] 的对象。Object.create(null) 是一种常见的模式，用来创建键值对对象。当创建的对象有从 Object.prototype 继承来的属性时，可能会导致错误出现。应防止在一个对象中直接调用 Object.prototype 的方法。 ❌ let hasBarProperty = foo.hasOwnProperty('bar') let isPrototypeOfBar = foo.isPrototypeOf(bar) let barIsEnumerable = foo.propertyIsEnumerable('bar') ✔ let hasBarProperty = Object.prototype.hasOwnProperty.call(foo, 'bar') let isPrototypeOfBar = Object.prototype.isPrototypeOf.call(foo, bar) let barIsEnumerable = {}.propertyIsEnumerable.call(foo, 'bar') 禁止正则表达式字面量中出现多个空格 正则表达式可以很复杂和难以理解，这就是为什么要保持它们尽可能的简单，以避免出现错误。你在使用正则表达式时最容易出错的是使用了多个空格，例如： let re = /foo bar/ 在这个正则表达式中，很难断定想要匹配多少个空格。最好是只使用一个空格，然后指定需要多少个，例如： let re = /foo {3}bar/ 现在非常清楚地知道需要匹配 3 个空格。 禁用稀疏数组 稀疏数组包括很多空位置，经常是由于在数组字面量中使用多个逗号造成的，例如： let items = [,,] 在这个例子中，item 数组的 length 为 2，实际上，items[0] 或 items[1]并没有值。数组中只有逗号是有效的，再加上 length 被设置，没有实际的值被设置，这些情况让很多开发者对稀疏数组感到困惑。考虑下面的情况： let colors = [ 'red',, 'blue' ] 在这个例子中，colors 数值的 length 是 3。但是否是开发者想让数组中间出现一个空元素？或者只是一个书写错误？ 稀疏数组的定义方式造成了很大的困惑，建议避免使用它们，除非你确定它们在你的代码中很有用。 禁止在常规字符串中出现模板字面量占位符语法 ECMAScript 6 允许程序员使用模板字面量创建包含变量或表达式的字符串，在两个反引号之间书写表达式比如 ${variable}，而不是使用字符串拼接。在使用模板字面量过程中很容易写错引号，写错成 '${variable}' 而不是在字符串中包含注入的表达式的值。 ❌ 'Hello ${name}!' 'Hello ${name}!' 'Time: ${12 * 60 * 60 * 1000}' ✔ `Hello ${name}!` `Time: ${12 * 60 * 60 * 1000}` `Hello ${name}` 禁止在 return、throw、continue 和 break 语句后出现不可达代码 因为 return、throw、continue 和 break 语句无条件地退出代码块，其之后的任何语句都不会被执行。不可达语句通常是个错误。 ❌ function foo() { return true console.log('done') } function bar() { throw new Error('Oops!') console.log('done') } while(value) { break console.log('done') } throw new Error('Oops!') console.log('done') function baz() { if (Math.random() ✔ function foo() { return bar() function bar() { return 1 } } 禁止对关系运算符的左操作数使用否定操作符 开发人员可能会把 -(a + b) 写错成 -a + b 来表示一个负数，也可能会把 !(key in object) 错写成 !key in object 来测试一个键是否在对象中。类似的情况也有 !obj instanceof Ctor。 关系运算符有： in 运算符. instanceof 运算符. ❌ if (!key in object) { //由于运算符优先级和类型转换以上代码等价于: (key ? 'false' : 'true') in object } if (!obj instanceof Ctor) { //因为!obj运算结果为boolean而boolean不是对象因此运算结果始终为false } ✔ if (!(key in object)) { } if (!(obj instanceof Ctor)) { } 要求调用 isNaN()检查 NaN 在 JavaScript 中，NaN 是 Number 类型的一个特殊值。它被用来表示非数值，这里的数值是指在 IEEE 浮点数算术标准中定义的双精度64位格式的值。 因为在 JavaScript 中 NaN 独特之处在于它不等于任何值，包括它本身，与 NaN 进行比较的结果是令人困惑： NaN !== NaN 或者 NaN != NaN 运算结果为true 因此，使用 Number.isNaN() 或 全局的 isNaN() 函数来测试一个值是否是 NaN。 ❌ if (foo == NaN) { // ... } if (foo != NaN) { // ... } ✔ if (isNaN(foo)) { // ... } if (!isNaN(foo)) { // ... } 强制数组方法的回调函数中有 return 语句 Array有一些方法用来过滤、映射和折叠。如果你忘记了在它们的回调函数中写return语句，这种情况可能是个错误。 // 例如将 ['a', 'b', 'c'] 转换成 {a: 1, b: 2, c: 3} 如果忘记return会报错 let indexMap = myArray.reduce(function(memo, item, index) { memo[item] = index }, {}) // Error: cannot set property 'b' of undefined 因此,请在以下数组方法中包含return语句 Array.from Array.prototype.every Array.prototype.filter Array.prototype.find Array.prototype.findIndex Array.prototype.map Array.prototype.reduce Array.prototype.reduceRight Array.prototype.some Array.prototype.sort ❌ let indexMap = myArray.reduce(function(memo, item, index) { memo[item] = index }, {}) let foo = Array.from(nodes, function(node) { if (node.tagName === 'DIV') { return true } }) let bar = foo.filter(function(x) { if (x) { return true } else { return } }) ✔ let indexMap = myArray.reduce(function(memo, item, index) { memo[item] = index return memo }, {}) let foo = Array.from(nodes, function(node) { if (node.tagName === 'DIV') { return true } return false }) let bar = foo.map(node => node.getAttribute('id')) 要求 Switch 语句中有 Default 分支 考虑到开发人员可能会忘记定义默认分支而导致程序发生错误，所以明确规定定义默认分支是很好的选择。 ❌ switch (a) { case 1: /* code */ break } ✔ switch (a) { case 1: /* code */ break default: /* code */ break } switch (a) { case 1: /* code */ break // no default } switch (a) { case 1: /* code */ break // No Default } 要求使用 === 和 !== 使用类型安全的 === 和 !== 操作符代替 == 和 != 操作符是一个很好的实践。 这样做的原因是，== 和 != 遵循 Abstract Equality Comparison Algorithm 作强制转型. 例如，以下语句被认为是 true。 [] == false [] == ![] 3 == '03' 如果它们中的任何一个出现在一个看上去无害的语句中，比如 a == b ，那么实际的问题是很难 被发现的。 ❌ if (x == 42) { } if ('' == text) { } if (obj.getStuff() != undefined) { } ✔ if (x === 42) { } if ('' === text) { } 禁止在 case 或 default 子句中出现词法声明 禁止词法声明 (let、const、function 和 class) 出现在 case或default 子句中。原因是，词法声明在整个 switch 语句块中是可见的，但是它只有在运行到它定义的 case 语句时，才会进行初始化操作。 为了保证词法声明语句只在当前 case 语句中有效，将声明子句包裹在块中。 ❌ switch (foo) { case 1: let x = 1 break case 2: const y = 2 break case 3: function f() {} break default: class C {} } ✔ const a = 0 switch (foo) { case 1: { let x = 1 break } case 2: { const y = 2 break } case 3: { function f() {} break } default: { class C {} } } 小数点前面和后面应该有一个数字 在 JavaScript 中，浮点值会包含一个小数点，没有要求小数点之前或之后必须有一个数字。例如，以下例子都是有效的 JavaScript 数字： let num1 = .5 let num2 = 2. let num3 = -.7 虽然不是一个语法错误，这种格式的数字使真正的小数和点操作符变的难以区分。由于这个原因，有些人建议应该总是在小数点前面和后面有一个数字，以明确表明是要创建一个小数。 ❌ let num1 = .5 let num2 = 2. let num3 = -.7 ✔ let num1 = 0.5 let num2 = 2.0 let num3 = -0.7 禁止使用较短的符号实现类型转换 在 JavaScript 中，有许多不同的方式进行类型转换。其中有些可能难于阅读和理解。 例如： let b = !!foo let b = ~foo.indexOf('.') let n = +foo let n = 1 * foo let s = '' + foo foo += `` 可以使用下面的代码替换: let b = Boolean(foo) let b = foo.indexOf('.') !== -1 let n = Number(foo) let n = Number(foo) let s = String(foo) foo = String(foo) 禁止使用空解构模式 当使用解构赋值时，可能创建了一个不起作用的模式。把空的花括号放在嵌入的对象的解构模式右边时，就会产生这种情况，例如： // 以下代码不会创建任何变量 let {a: {}} = foo 在以上代码中，没有创建新的变量，因为 a 只是一个辅助位置，而 {} 将包含创建的变量，例如： // 创建变量 b let {a: { b }} = foo 在许多情况下，作者本来打算使用一个默认值，却错写成空对象，例如： // 创建一个默认值为{}的变量a let {a = {}} = foo 这两种模式直接的区别是微妙的，因为空模式看起来像是一个对象字面量。 ❌ let {} = foo let [] = foo let {a: {}} = foo let {a: []} = foo function foo({}) {} function foo([]) {} function foo({a: {}}) {} function foo({a: []}) {} ✔ let {a = {}} = foo let {a = []} = foo function foo({a = {}}) {} function foo({a = []}) {} 禁用不必要的 return await 在 async function， return await 是没有用的 。因为 async function 的返回值总是包裹在 Promise.resolve，在 Promise resolve 或 reject 之前，return await 实际上不会做任何事情。这种模式几乎可以肯定是由于程序员不知道 async function 语法的返回值造成的。 ❌ async function foo() { return await bar() } ✔ async function foo() { return bar() } async function foo() { await bar() return } async function foo() { const x = await bar() return x } async function foo() { try { // await 是必须的，可以捕获从 bar() 抛出的错误 return await bar() } catch (error) {} } 禁止未使用过的变量 已声明的变量在代码里未被使用过，就像是由于不完整的重构而导致的遗漏错误。这样的变量增加了代码量，并且混淆读者。 派生类中的构造函数必须调用 super(),非派生类的构造函数不能调用 super() ❌ class A extends B { constructor() { } // ReferenceError. } ✔ class A { constructor() { } } class A extends B { constructor() { super() } } 禁止重复导入 为每个模块使用单一的 import 语句会是代码更加清晰，因为你会看到从该模块导入的所有内容都在同一行。 在下面的例子中，行 1 和 行 3 的模块导入是重复的。二者合并会使导入列表更加简洁。 import { merge } from 'module' import something from 'another-module' import { find } from 'module' ❌ mport { merge } from 'module' import something from 'another-module' import { find } from 'module' ✔ import { merge, find } from 'module' import something from 'another-module' 要求使用 let 或 const 而不是 var ECMAScript 6 允许程序员使用 let 和 const 关键字在块级作用域而非函数作用域下声明变量。块级作用域在很多其他编程语言中很普遍，能帮助程序员避免错误，例如： var count = people.length var enoughFood = count > sandwiches.length if (enoughFood) { var count = sandwiches.length // 无意中覆盖了变量count console.log('We have ' + count + ' sandwiches for everyone. Plenty for all!') } // count的值不再为people.length console.log('We have ' + count + ' people and ' + sandwiches.length + 'sandwiches!') ❌ var x = 'y' var CONFIG = {} ✔ let x = 'y' const CONFIG = {} 建议使用const 如果一个变量不会被重新赋值，最好使用const进行声明。 const 声明告诉读者，“这个变量从不会被重新赋值”，从而减少认知负荷，提高可维护性。 建议使用剩余参数代替 arguments ES2015 里有剩余参数。我们可以利用这个特性代替变参函数的 arguments 变量。 arguments 没有 Array.prototype 方法，所以有点不方便。 ❌ function foo() { console.log(arguments) } function foo(action) { let args = Array.prototype.slice.call(arguments, 1) action.apply(null, args) } function foo(action) { let args = [].slice.call(arguments, 1) action.apply(null, args) } ✔ function foo(...args) { console.log(args) } function foo(action, ...args) { action(...args) } 建议使用扩展运算符而非.apply() 在 ES2015 之前，必须使用 Function.prototype.apply() 调用可变参数函数。 let args = [1, 2, 3, 4] Math.max.apply(Math, args) 在 ES2015 中，可以使用扩展运算符调用可变参数函数。 let args = [1, 2, 3, 4] Math.max(...args) "},"vue开发规范.html":{"url":"vue开发规范.html","title":"vue开发规范","keywords":"","body":"vue开发规范 组件数据 组件的 data 必须是一个函数。 当在组件中使用 data 属性的时候 (除了 new Vue 外的任何地方)，它的值必须是返回一个对象的函数。 反例 Vue.component('some-comp', { data: { foo: 'bar' } }) export default { data: { foo: 'bar' } } 好例子 Vue.component('some-comp', { data: function () { return { foo: 'bar' } } }) export default { data () { return { foo: 'bar' } } } // 在一个 Vue 的根实例上直接使用对象是可以的， // 因为只存在一个这样的实例。 new Vue({ data: { foo: 'bar' } }) Prop 定义 Prop 定义应该尽量详细。 在你提交的代码中，prop 的定义应该尽量详细，至少需要指定其类型。 反例 // 这样做只有开发原型系统时可以接受 props: ['status'] 好例子 props: { status: String } 更好的做法！ props: { status: { type: String, required: true, validator: function (value) { return [ 'syncing', 'synced', 'version-conflict', 'error' ].indexOf(value) !== -1 } } } 为 v-for 设置键值 总是用 key 配合 v-for。 在组件上总是必须用 key 配合 v-for，以便维护内部组件及其子树的状态。甚至在元素上维护可预测的行为，比如动画中的对象固化 (object constancy)，也是一种好的做法。 反例 好例子 避免 v-if 和 v-for 用在一起 永远不要把 v-if 和 v-for 同时用在同一个元素上。 一般我们在两种常见的情况下会倾向于这样做： 为了过滤一个列表中的项目 (比如 v-for=\"user in users\" v-if=\"user.isActive\")。在这种情形下，请将 users 替换为一个计算属性 (比如 activeUsers)，让其返回过滤后的列表。 为了避免渲染本应该被隐藏的列表 (比如 v-for=\"user in users\" v-if=\"shouldShowUsers\")。这种情形下，请将 v-if 移动至容器元素上 (比如 ul, ol)。 反例 好例子 为组件样式设置作用域 对于应用来说，顶级 App 组件和布局组件中的样式可以是全局的，但是其它所有组件都应该是有作用域的。 这条规则只和单文件组件有关。你不一定要使用 scoped 特性。设置作用域也可以通过 CSS Modules，那是一个基于 class 的类似 BEM 的策略，当然你也可以使用其它的库或约定。 不管怎样，对于组件库，我们应该更倾向于选用基于 class 的策略而不是 scoped 特性。 这让覆写内部样式更容易：使用了常人可理解的 class 名称且没有太高的选择器优先级，而且不太会导致冲突。 反例 X .btn-close { background-color: red; } 好例子 X .button { border: none; border-radius: 2px; } .button-close { background-color: red; } X .button { border: none; border-radius: 2px; } .buttonClose { background-color: red; } X .c-Button { border: none; border-radius: 2px; } .c-Button--close { background-color: red; } 组件文件 只要有能够拼接文件的构建系统，就把每个组件单独分成文件。 当你需要编辑一个组件或查阅一个组件的用法时，可以更快速的找到它。 反例 Vue.component('TodoList', { // ... }) Vue.component('TodoItem', { // ... }) 好例子 components/ |- TodoList.js |- TodoItem.js components/ |- TodoList.vue |- TodoItem.vue 单文件组件文件的大小写 单文件组件的文件名应该始终是单词大写开头 (PascalCase) 单词大写开头对于代码编辑器的自动补全最为友好，因为这使得我们在 JS(X) 和模板中引用组件的方式尽可能的一致。 反例 components/ |- mycomponent.vue components/ |- myComponent.vue 好例子 components/ |- MyComponent.vue 基础组件名 应用特定样式和约定的基础组件 (也就是展示类的、无逻辑的或无状态的组件) 应该全部以一个特定的前缀开头，比如 Base、App 或 V。 反例 components/ |- MyButton.vue |- VueTable.vue |- Icon.vue 好例子 components/ |- BaseButton.vue |- BaseTable.vue |- BaseIcon.vue components/ |- AppButton.vue |- AppTable.vue |- AppIcon.vue components/ |- VButton.vue |- VTable.vue |- VIcon.vue 紧密耦合的组件名 和父组件紧密耦合的子组件应该以父组件名作为前缀命名。 如果一个组件只在某个父组件的场景下有意义，这层关系应该体现在其名字上。因为编辑器通常会按字母顺序组织文件，所以这样做可以把相关联的文件排在一起。 反例 components/ |- TodoList.vue |- TodoItem.vue |- TodoButton.vue components/ |- SearchSidebar.vue |- NavigationForSearchSidebar.vue 好例子 components/ |- TodoList.vue |- TodoListItem.vue |- TodoListItemButton.vue components/ |- SearchSidebar.vue |- SearchSidebarNavigation.vue 组件名中的单词顺序 组件名应该以高级别的(通常是一般化描述的) 单词开头，以描述性的修饰词结尾。 反例 components/ |- ClearSearchButton.vue |- ExcludeFromSearchInput.vue |- LaunchOnStartupCheckbox.vue |- RunSearchButton.vue |- SearchInput.vue |- TermsCheckbox.vue 好例子 components/ |- SearchButtonClear.vue |- SearchButtonRun.vue |- SearchInputQuery.vue |- SearchInputExcludeGlob.vue |- SettingsCheckboxTerms.vue |- SettingsCheckboxLaunchOnStartup.vue 自闭合组件 在单文件组件、字符串模板和 JSX 中没有内容的组件应该是自闭合的——但在 DOM 模板里永远不要这样做。 自闭合组件表示它们不仅没有内容，而且刻意没有内容。其不同之处就好像书上的一页白纸对比贴有“本页有意留白”标签的白纸。而且没有了额外的闭合标签，你的代码也更简洁。 不幸的是，HTML 并不支持自闭合的自定义元素——只有官方的“空”元素。所以上述策略仅适用于进入 DOM 之前 Vue 的模板编译器能够触达的地方，然后再产出符合 DOM 规范的 HTML。 反例 好例子 模板中的组件名大小写 组件模板中的组件名应该始终是kebab-case 反例 好例子 JS/JSX 中的组件名大小写 JS/JSX 中的组件名应该始终是 PascalCase 的，尽管在较为简单的应用中只使用 Vue.component 进行全局组件注册时，可以使用 kebab-case 字符串。 反例 Vue.component('myComponent', { // ... }) import myComponent from './MyComponent.vue' export default { name: 'myComponent', // ... } export default { name: 'my-component', // ... } 好例子 Vue.component('MyComponent', { // ... }) Vue.component('my-component', { // ... }) import MyComponent from './MyComponent.vue' export default { name: 'MyComponent', // ... } Prop 名大小写 在声明 prop 的时候，其命名应该始终使用 camelCase，而在模板和 JSX 中应该始终使用 kebab-case。 我们单纯的遵循每个语言的约定。在 JavaScript 中更自然的是 camelCase。而在 HTML 中则是 kebab-case。 反例 props: { 'greeting-text': String } 好例子 props: { greetingText: String } 多个特性的元素 多个特性的元素应该分多行撰写，每个特性一行。 在 JavaScript 中，用多行分隔对象的多个属性是很常见的最佳实践，因为这样更易读。模板和 JSX 值得我们做相同的考虑。 反例 好例子 模板中简单的表达式 组件模板应该只包含简单的表达式，复杂的表达式则应该重构为计算属性或方法。 复杂表达式会让你的模板变得不那么声明式。我们应该尽量描述应该出现的是什么，而非如何计算那个值。而且计算属性和方法使得代码可以重用。 反例 {{ fullName.split(' ').map(word => { return word[0].toUpperCase() + word.slice(1) }).join(' ') }} 好例子 // 复杂表达式已经移入一个计算属性 computed: { normalizedFullName: function () { return this.fullName.split(' ').map(function (word) { return word[0].toUpperCase() + word.slice(1) }).join(' ') } } 简单的计算属性 应该把复杂计算属性分割为尽可能多的更简单的属性。 反例 computed: { price: function () { var basePrice = this.manufactureCost / (1 - this.profitMargin) return ( basePrice - basePrice * (this.discountPercent || 0) ) } } 好例子 computed: { basePrice: function () { return this.manufactureCost / (1 - this.profitMargin) }, discount: function () { return this.basePrice * (this.discountPercent || 0) }, finalPrice: function () { return this.basePrice - this.discount } } 带引号的特性值 非空 HTML 特性值应该始终带双引号 在 HTML 中不带空格的特性值是可以没有引号的，但这鼓励了大家在特征值里不写空格，导致可读性变差。 反例 好例子 指令缩写 指令缩写 (用 : 表示 v-bind: 和用 @ 表示 v-on:) 反例 好例子 单文件组件的顶级元素的顺序 单文件组件应该总是让 、 和 标签的顺序保持一致。且 要放在最后，因为另外两个标签至少要有一个。 反例 /* ... */ /* ... */ ... /* ... */ ... /* ... */ 好例子 ... /* ... */ /* ... */ ... /* ... */ /* ... */ scoped 中的元素选择器 元素选择器应该避免在 scoped 中出现。 在 scoped 样式中，类选择器比元素选择器更好，因为大量使用元素选择器是很慢的。 反例 X button { background-color: red; } 好例子 X .btn-close { background-color: red; } 隐性的父子组件通信 应该优先通过 prop 和事件进行父子组件之间的通信，而不是 this.$parent 或改变 prop。 一个理想的 Vue 应用是 prop 向下传递，事件向上传递的。遵循这一约定会让你的组件更易于理解。然而，在一些边界情况下 prop 的变更或 this.$parent 能够简化两个深度耦合的组件。 问题在于，这种做法在很多简单的场景下可能会更方便。但请当心，不要为了一时方便 (少写代码) 而牺牲数据流向的简洁性 (易于理解)。 反例 Vue.component('TodoItem', { props: { todo: { type: Object, required: true } }, template: '' }) Vue.component('TodoItem', { props: { todo: { type: Object, required: true } }, methods: { removeTodo () { let vm = this vm.$parent.todos = vm.$parent.todos.filter(function (todo) { return todo.id !== vm.todo.id }) } }, template: ` X ` }) 好例子 Vue.component('TodoItem', { props: { todo: { type: Object, required: true } }, template: ` ` }) Vue.component('TodoItem', { props: { todo: { type: Object, required: true } }, template: ` X ` }) 禁止在计算属性中出现异步操作 计算属性应该是同步的. 计算属性中的异步操作不能按预期地执行,并且可能引发异常 反例 export default { computed: { pro () { return Promise.all([new Promise((resolve, reject) => {})]) }, foo1: async function () { return await someFunc() }, bar () { return fetch(url).then(response => {}) }, tim () { setTimeout(() => { }, 0) }, inter () { setInterval(() => { }, 0) }, anim () { requestAnimationFrame(() => {}) } } } 好例子 export default { computed: { foo () { let bar = 0 try { bar = bar / this.a } catch (e) { return 0 } finally { return bar } } } } 不要写有副作用的计算属性 在计算属性中引入副作用被认为是一种非常糟糕的做法,它使代码不可预测且难以理解. 反例 export default { computed: { fullName () { this.firstName = 'lorem' return `${this.firstName} ${this.lastName}` // 引发副作用,this.firstName被改变 }, reversedArray () { return this.array.reverse() // 引发副作用,原数组被改变了 } } } 好例子 export default { computed: { fullName () { return `${this.firstName} ${this.lastName}` }, reversedArray () { return this.array.slice(0).reverse() // .slice(0)产生原数组的副本,原数组没被改变 } } } 计算属性必需有返回值 反例 export default { computed: { baz () { if (this.baf) { return this.baf } }, baf: function () {} } } 好例子 export default { computed: { foo () { if (this.bar) { return this.baz } else { return this.baf } }, bar: function () { return false } } } props的默认值应该是有效的 反例 script> export default { props: { propA: { type: String, default: {} }, propB: { type: String, default: [] }, propC: { type: Object, default: [] }, propD: { type: Array, default: [] }, propE: { type: Object, default: { message: 'hello' } } } } 好例子 script> export default { props: { propA: Number, propB: [String, Number], propD: { type: Number, default: 100 }, // Array和Object类型的default值应该是一个返回对应类型值的函数 propE: { type: Object, default() { return { message: 'hello' } } }, propF: { type: Array, default() { return [] } } } } "},"前端最佳实践.html":{"url":"前端最佳实践.html","title":"前端最佳实践","keywords":"","body":"前端最佳实践 CSS类名嵌套方式 最佳 header body footer .my-comp{ &-wrap{ // ... } &-header{ // ... } &-body{ // ... } &-footer{ // ... } } 不建议 header body footer .my-comp-wrap{ .header{ // ... } .body{ // ... } .footer{ // ... } } 最好不要 header body footer .my-comp-wrap{ .header{ // ... } .body{ // ... } .footer{ // ... } } 不允许 header body footer .my-comp-wrap{ //... } .header{ // ... } .body{ // ... } .footer{ // ... } 中使用的常量不要写在data中 vue组件中的data一般应该存放将来会变化的数据,如果在其中存放大量常量数据,不仅影响性能,而且会让代码很难理解 好例子 btn export default { data() { return { value: 5 } } } 坏例子 btn export default { data() { return { min: 2, max: 10, btnColor: 'primary', btnSize: 'large' value: 5, } } } 中不要直接使用vuex中的state和getters 坏例子 login 好例子 login import { mapState, mapGetters } from \"vuex\" export default { computed: { ...mapState(\"user\", [\"userName\"]), ...mapGetters(\"user\", [\"hasLogedIn\"]) } } vuex中mutations和actions应该使用大写 坏例子 mutations: { increment (state) { state.count++ } } actions: { increment ({ commit }) { commit('increment') } } 好例子 mutations: { INCREMENT (state) { state.count++ } } actions: { INCREMENT ({ commit }) { commit('INCREMENT') } } v-for中不要出现重复的key 坏例子 export default { data(){ return { items: ['item1', 'item2', 'item1'] } } } 好例子 export default { data(){ return { items: ['item1', 'item2', 'item1'] } } } 应该把公共的代码写成组件,而不是内联代码 坏例子 // UserGameRank.vue iconfont-user iconfont-game function parseRankToIcons(rank){ return { suns: Math.floor(rank / 16), moons: Math.floor((rank % 16) / 4), stars: rank % 4 } } export default { data(){ return { userRank: 10, gameRank: 12 } }, computed: { userRankIcons(){ return parseRankToIcons(this.userRank) }, gameRankIcons(){ return parseRankToIcons(this.gameRank) } } } 好例子 // UserRank.vue export default { props: { rank: { type: Number, default: 0, required: true } }, computed: { icons() { return { suns: Math.floor(this.rank / 16), moons: Math.floor((this.rank % 16) / 4), stars: this.rank % 4 } } } } // UserGameRank.vue iconfont-user iconfont-game export default { data(){ return { userRank: 10, gameRank: 12 } } } 把公共的代码写在mixin里 坏例子 // FollowTopic.vue 关注话题 export default { methods:{ onFollowTopic(){ if(!this.$store.user.userInfo.id){ this.$router.replace({ path: '/login', query: { redirect: this.$route.fullPath } }) } else{ // to follow topic } } } } // FollowUser.vue 关注用户 export default { methods:{ onFollowUser(){ if(!this.$store.user.userInfo.id){ this.$router.replace({ path: '/login', query: { redirect: this.$route.fullPath } }) } else{ // to follow user } } } } 好例子 // RedirectToLogin.js /** * 需要登录的组件可以在点击事件中绑定onCheckLogin或手动调用以在未登录时跳转登录页 */ export default { methods: { /** * @param {MouseEvent} e */ onCheckLogin(e) { if (!this.$store.getters.userInfo.id) { e && e.stopPropagation() this.$router.replace({ path: '/login', query: { redirect: this.$route.fullPath } }) return false } else { return true } } } } // FollowTopic.vue 关注话题 import RedirectToLogin from '@mixins/RedirectToLogin.js' export default { mixins: [RedirectToLogin], methods:{ onFollowTopic(){ if(this.onCheckLogin()){ // to follow topic } } } } // FollowUser.vue 关注用户 import RedirectToLogin from '@mixins/RedirectToLogin.js' export default { mixins: [RedirectToLogin], methods:{ onFollowUser(){ if(this.onCheckLogin()){ // to follow user } } } } 用好组件库 坏例子 已关注 export default { methods:{ mouseover: function(e) { e.target.innerText = '取消关注' }, mouseout: function(e) { e.target.innerText = '已关注' } } } 好例子 {{ hover ? '取消关注' : '已关注' }} 服务器端渲染时,不要在beforeCreate,created中设置timer 坏例子 export default { created(){ this.timer = setInterval(() => { }, 5000) }, beforeDestroy(){ // 这段代码在服务器端不会运行,因此timer不会被清除,会影响服务器性能 clearTimeout(this.timer) } } 好例子 export default { mounted(){ // 这段代码不会在服务器端运行 this.timer = setInterval(() => { }, 5000); }, beforeDestroy(){ clearTimeout(this.timer) } } // 或者,在nuxt框架下 export default { created(){ if(!process.server){ // 这段代码不会在服务器端运行 this.timer = setInterval(() => { }, 5000); } }, beforeDestroy(){ clearTimeout(this.timer) } } 合理精简重复的代码 反例 import { removeToken } from '@/utils/auth' export const state = () => ({ userInfo: { accountEmail: '', accountMobile: '', experiencePoints: 0, followedCount: 0, followerCount: 0, id: '', rank: 0, reputationPoints: 0, siteId: '', tradePoints: 0, trueName: '', userName: '' } }) export const mutations = { SET_USERINFO: (state, userInfo) => { state.userInfo.accountMobile = userInfo.accountMobile state.userInfo.accountEmail = userInfo.accountEmail state.userInfo.experiencePoints = userInfo.experiencePoints state.userInfo.followedCount = userInfo.followedCount state.userInfo.followerCount = userInfo.followerCount state.userInfo.id = userInfo.id state.userInfo.rank = userInfo.rank state.userInfo.reputationPoints = userInfo.reputationPoints state.userInfo.siteId = userInfo.siteId state.userInfo.tradePoints = userInfo.tradePoints state.userInfo.trueName = userInfo.trueName state.userInfo.userName = userInfo.userName } } export const actions = { // 登出 LOGOUT: function({ commit, state }) { removeToken() commit('SET_USERINFO', { accountEmail: '', accountMobile: '', experiencePoints: 0, followedCount: 0, followerCount: 0, id: '', rank: 0, reputationPoints: 0, siteId: '', tradePoints: 0, trueName: '', userName: '' }) } } export const namespaced = false 好例子 import { removeToken } from '@/utils/auth' const defaultUserInfo = () => ({ accountEmail: '', accountMobile: '', experiencePoints: 0, followedCount: 0, followerCount: 0, id: '', rank: 0, reputationPoints: 0, siteId: '', tradePoints: 0, trueName: '', userName: '' }) export const state = () => ({ userInfo: defaultUserInfo() }) export const mutations = { SET_USERINFO: (state, userInfo) => { Object.assign(state.userInfo, userInfo) } } export const actions = { // 登出 LOGOUT: function({ commit, state }) { removeToken() commit('SET_USERINFO', defaultUserInfo()) } } export const namespaced = false "}}